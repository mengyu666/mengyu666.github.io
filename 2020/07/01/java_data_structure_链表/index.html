<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="master">





<title>Java_data_structure_链表 | rmy&#39;s blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">rmy&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">rmy&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java_data_structure_链表</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">master</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 1, 2020&nbsp;&nbsp;16:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            
        <div id="aplayer-AkobbzOx" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-AkobbzOx"),
            narrow: false,
            autoplay: true,
            showlrc: false,
            music: {
              title: "年少有为",
              author: "李荣浩",
              url: "http://music.163.com/song/media/outer/url?id=1293886117.mp3",
              pic: "/music/pictures/musiclrh.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><h2 id="创建一个类，声明的的每一个对象都是一个单链表的节点"><a href="#创建一个类，声明的的每一个对象都是一个单链表的节点" class="headerlink" title="创建一个类，声明的的每一个对象都是一个单链表的节点"></a>创建一个类，声明的的每一个对象都是一个单链表的节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义HeroNode ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">	public int no;</span><br><span class="line">	public String name;</span><br><span class="line">	public String nickname;</span><br><span class="line">	public HeroNode next; &#x2F;&#x2F;指向下一个节点</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">		this.no &#x3D; no;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.nickname &#x3D; nickname;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;为了显示方法，我们重新toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickname&#x3D;&quot; + nickname + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建一个类，声明的的每一个对象都是一条单链表"><a href="#创建一个类，声明的的每一个对象都是一条单链表" class="headerlink" title="创建一个类，声明的的每一个对象都是一条单链表"></a>创建一个类，声明的的每一个对象都是一条单链表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义SingleLinkedList 管理我们的英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">	private HeroNode head &#x3D; new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;返回头节点</span><br><span class="line">	public HeroNode getHead() &#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;添加节点到单向链表</span><br><span class="line">    &#x2F;&#x2F;在链表的末尾添加</span><br><span class="line">	public void add(HeroNode heroNode) &#123; </span><br><span class="line">        ……</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *添加节点到单向链表</span><br><span class="line">	 *根据排名将英雄插入到指定位置</span><br><span class="line">     *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;(如果有这个排名，则添加失败，并给出提示)</span><br><span class="line">	public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">		……</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;修改节点的信息</span><br><span class="line">	public void update(HeroNode newHeroNode) &#123;</span><br><span class="line">		……</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;删除节点</span><br><span class="line">	</span><br><span class="line">	public void delete(int no) &#123;</span><br><span class="line">		……</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;显示链表[遍历]</span><br><span class="line">	public void list() &#123;</span><br><span class="line">        ……</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加节点到单向链表"><a href="#添加节点到单向链表" class="headerlink" title="添加节点到单向链表"></a>添加节点到单向链表</h2><ul>
<li>在链表的末尾顺次添加</li>
<li>在链表的指定位置添加<h3 id="在链表的末尾添加"><a href="#在链表的末尾添加" class="headerlink" title="在链表的末尾添加"></a>在链表的末尾添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void add(HeroNode heroNode) &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">	HeroNode temp &#x3D; head;</span><br><span class="line">	&#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">	while(true) &#123;</span><br><span class="line">		&#x2F;&#x2F;找到链表的最后</span><br><span class="line">		if(temp.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;如果没有找到最后, 将将temp后移</span><br><span class="line">		temp &#x3D; temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;当退出while循环时，temp就指向了链表的最后</span><br><span class="line">	&#x2F;&#x2F;将最后这个节点的next 指向 新的节点</span><br><span class="line">	temp.next &#x3D; heroNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在指定位置添加"><a href="#在指定位置添加" class="headerlink" title="在指定位置添加"></a>在指定位置添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在添加英雄时，根据排名将英雄插入到指定位置</span><br><span class="line">&#x2F;&#x2F;(如果有这个排名，则添加失败，并给出提示)</span><br><span class="line">public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">	&#x2F;&#x2F;因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span><br><span class="line">	&#x2F;&#x2F;因为单链表，因为我们找的temp是位于 添加位置的前一个节点，否则插入不了</span><br><span class="line">	HeroNode temp &#x3D; head;</span><br><span class="line">	boolean flag &#x3D; false; &#x2F;&#x2F; flag标志添加的编号是否存在，默认为false</span><br><span class="line">	while(true) &#123;</span><br><span class="line">		if(temp.next &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;说明temp已经在链表的最后</span><br><span class="line">			break; </span><br><span class="line">		&#125; </span><br><span class="line">		if(temp.next.no &gt; heroNode.no) &#123; &#x2F;&#x2F;位置找到，就在temp的后面插入</span><br><span class="line">			break;</span><br><span class="line">		&#125; else if (temp.next.no &#x3D;&#x3D; heroNode.no) &#123;&#x2F;&#x2F;说明希望添加的heroNode的编号已然存在</span><br><span class="line">			</span><br><span class="line">			flag &#x3D; true; &#x2F;&#x2F;说明编号存在</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		temp &#x3D; temp.next; &#x2F;&#x2F;后移，遍历当前链表</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;判断flag 的值</span><br><span class="line">	if(flag) &#123; &#x2F;&#x2F;不能添加，说明编号存在</span><br><span class="line">		System.out.printf(&quot;准备插入的英雄的编号 %d 已经存在了, 不能加入\n&quot;, heroNode.no);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		&#x2F;&#x2F;插入到链表中, temp的后面</span><br><span class="line">		heroNode.next &#x3D; temp.next;</span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改节点的信息"><a href="#修改节点的信息" class="headerlink" title="修改节点的信息"></a>修改节点的信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void update(HeroNode newHeroNode) &#123;</span><br><span class="line">	&#x2F;&#x2F;判断是否空</span><br><span class="line">	if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">		System.out.println(&quot;链表为空~&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;找到需要修改的节点, 根据no编号</span><br><span class="line">	&#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">	HeroNode temp &#x3D; head.next;</span><br><span class="line">	boolean flag &#x3D; false; &#x2F;&#x2F;表示是否找到该节点</span><br><span class="line">	while(true) &#123;</span><br><span class="line">		if (temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">			break; &#x2F;&#x2F;已经遍历完链表</span><br><span class="line">		&#125;</span><br><span class="line">		if(temp.no &#x3D;&#x3D; newHeroNode.no) &#123;</span><br><span class="line">			&#x2F;&#x2F;找到</span><br><span class="line">			flag &#x3D; true;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		temp &#x3D; temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;根据flag 判断是否找到要修改的节点</span><br><span class="line">	if(flag) &#123;</span><br><span class="line">		temp.name &#x3D; newHeroNode.name;</span><br><span class="line">		temp.nickname &#x3D; newHeroNode.nickname;</span><br><span class="line">	&#125; else &#123; &#x2F;&#x2F;没有找到</span><br><span class="line">		System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除某一个节点"><a href="#删除某一个节点" class="headerlink" title="删除某一个节点"></a>删除某一个节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void delete(int no) &#123;</span><br><span class="line">	HeroNode temp &#x3D; head;</span><br><span class="line">	boolean flag &#x3D; false; &#x2F;&#x2F; 标志是否找到待删除节点的</span><br><span class="line">	while(true) &#123;</span><br><span class="line">		if(temp.next &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;已经到链表的最后</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(temp.next.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">			&#x2F;&#x2F;找到的待删除节点的前一个节点temp</span><br><span class="line">			flag &#x3D; true;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		temp &#x3D; temp.next; &#x2F;&#x2F;temp后移，遍历</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;判断flag</span><br><span class="line">	if(flag) &#123; &#x2F;&#x2F;找到</span><br><span class="line">		&#x2F;&#x2F;可以删除</span><br><span class="line">		temp.next &#x3D; temp.next.next;</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		System.out.printf(&quot;要删除的 %d 节点不存在\n&quot;, no);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="显示、遍历单链表"><a href="#显示、遍历单链表" class="headerlink" title="显示、遍历单链表"></a>显示、遍历单链表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void list() &#123;</span><br><span class="line">	&#x2F;&#x2F;判断链表是否为空</span><br><span class="line">	if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">		System.out.println(&quot;链表为空&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">	HeroNode temp &#x3D; head.next;</span><br><span class="line">	while(true) &#123;</span><br><span class="line">		&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">		if(temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;输出节点的信息</span><br><span class="line">		System.out.println(temp);</span><br><span class="line">		&#x2F;&#x2F;将temp后移， 一定小心</span><br><span class="line">		temp &#x3D; temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取到单链表的节点的个数-如果是带头结点的链表，需求不统计头节点"><a href="#获取到单链表的节点的个数-如果是带头结点的链表，需求不统计头节点" class="headerlink" title="获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)"></a>获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * @param head 链表的头节点</span><br><span class="line"> * @return 返回的就是有效节点的个数</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int getLength(HeroNode head) &#123;</span><br><span class="line">	if(head.next &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;空链表</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int length &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;定义一个辅助的变量, 这里我们没有统计头节点</span><br><span class="line">	HeroNode cur &#x3D; head.next;</span><br><span class="line">	while(cur !&#x3D; null) &#123;</span><br><span class="line">		length++;</span><br><span class="line">		cur &#x3D; cur.next; &#x2F;&#x2F;遍历</span><br><span class="line">	&#125;</span><br><span class="line">	return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将单链表反转"><a href="#将单链表反转" class="headerlink" title="将单链表反转"></a>将单链表反转</h2><h3 id="直接改变该单链表本身的结构"><a href="#直接改变该单链表本身的结构" class="headerlink" title="直接改变该单链表本身的结构"></a>直接改变该单链表本身的结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void reversetList(HeroNode head) &#123;</span><br><span class="line">	&#x2F;&#x2F;如果当前链表为空，或者只有一个节点，无需反转，直接返回</span><br><span class="line">	if(head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span><br><span class="line">	HeroNode cur &#x3D; head.next;</span><br><span class="line">	HeroNode next &#x3D; null;&#x2F;&#x2F; 指向当前节点[cur]的下一个节点</span><br><span class="line">	HeroNode reverseHead &#x3D; new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line">	&#x2F;&#x2F;遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span><br><span class="line">	while(cur !&#x3D; null) &#123; </span><br><span class="line">		next &#x3D; cur.next;&#x2F;&#x2F;先暂时保存当前节点的下一个节点，因为后面需要使用</span><br><span class="line">		cur.next &#x3D; reverseHead.next;&#x2F;&#x2F;将cur的下一个节点指向新的链表的最前端</span><br><span class="line">		reverseHead.next &#x3D; cur; &#x2F;&#x2F;将cur 连接到新的链表上</span><br><span class="line">		cur &#x3D; next;&#x2F;&#x2F;让cur后移</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;将head.next 指向 reverseHead.next , 实现单链表的反转</span><br><span class="line">	head.next &#x3D; reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用栈这个数据结构"><a href="#利用栈这个数据结构" class="headerlink" title="利用栈这个数据结构"></a>利用栈这个数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span><br><span class="line">public static void reversePrint(HeroNode head) &#123;</span><br><span class="line">	if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return;&#x2F;&#x2F;空链表，不能打印</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;创建要给一个栈，将各个节点压入栈</span><br><span class="line">	Stack&lt;HeroNode&gt; stack &#x3D; new Stack&lt;HeroNode&gt;();</span><br><span class="line">	HeroNode cur &#x3D; head.next;</span><br><span class="line">	&#x2F;&#x2F;将链表的所有节点压入栈</span><br><span class="line">	while(cur !&#x3D; null) &#123;</span><br><span class="line">		stack.push(cur);</span><br><span class="line">		cur &#x3D; cur.next; &#x2F;&#x2F;cur后移，这样就可以压入下一个节点</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;将栈中的节点进行打印,pop 出栈</span><br><span class="line">	while (stack.size() &gt; 0) &#123;</span><br><span class="line">		System.out.println(stack.pop()); &#x2F;&#x2F;stack的特点是先进后出</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找单链表中的倒数第k个结点"><a href="#查找单链表中的倒数第k个结点" class="headerlink" title="查找单链表中的倒数第k个结点"></a>查找单链表中的倒数第k个结点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;思路</span><br><span class="line">&#x2F;&#x2F;1. 编写一个方法，接收head节点，同时接收一个index </span><br><span class="line">&#x2F;&#x2F;2. index 表示是倒数第index个节点</span><br><span class="line">&#x2F;&#x2F;3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span><br><span class="line">&#x2F;&#x2F;4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span><br><span class="line">&#x2F;&#x2F;5. 如果找到了，则返回该节点，否则返回nulll</span><br><span class="line">public static HeroNode findLastIndexNode(HeroNode head, int index) &#123;</span><br><span class="line">	&#x2F;&#x2F;判断如果链表为空，返回null</span><br><span class="line">	if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return null;&#x2F;&#x2F;没有找到</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;第一个遍历得到链表的长度(节点个数)</span><br><span class="line">	int size &#x3D; getLength(head);</span><br><span class="line">	&#x2F;&#x2F;第二次遍历  size-index 位置，就是我们倒数的第K个节点</span><br><span class="line">	&#x2F;&#x2F;index的校验</span><br><span class="line">	if(index &lt;&#x3D;0 || index &gt; size) &#123;</span><br><span class="line">		return null; </span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;定义给辅助变量， for 循环定位到倒数的index</span><br><span class="line">	HeroNode cur &#x3D; head.next; &#x2F;&#x2F;3 &#x2F;&#x2F; 3 - 1 &#x3D; 2</span><br><span class="line">	for(int i &#x3D;0; i&lt; size - index; i++) &#123;</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return cur;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;进行测试</span><br><span class="line">		&#x2F;&#x2F;先创建节点</span><br><span class="line">		HeroNode hero1 &#x3D; new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">		HeroNode hero2 &#x3D; new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">		HeroNode hero3 &#x3D; new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">		HeroNode hero4 &#x3D; new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;创建要给链表</span><br><span class="line">		SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;把节点放到链表中</span><br><span class="line">		singleLinkedList.add(hero1);</span><br><span class="line">		singleLinkedList.add(hero4);</span><br><span class="line">		singleLinkedList.add(hero2);</span><br><span class="line">		singleLinkedList.add(hero3);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 测试单链表的反转功能</span><br><span class="line">		System.out.println(&quot;原来链表的情况~~&quot;);</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;反转单链表方法一&quot;);</span><br><span class="line">		reversetList(singleLinkedList.getHead());</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">        System.out.println(&quot;反转单链表方法二&quot;);</span><br><span class="line">		reversePrint(singleLinkedList.getHead());</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">&#x2F;*		</span><br><span class="line">		&#x2F;&#x2F;加入按照编号的顺序</span><br><span class="line">		singleLinkedList.addByOrder(hero1);</span><br><span class="line">		singleLinkedList.addByOrder(hero4);</span><br><span class="line">		singleLinkedList.addByOrder(hero2);</span><br><span class="line">		singleLinkedList.addByOrder(hero3);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;显示</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;测试修改节点的代码</span><br><span class="line">		HeroNode newHeroNode &#x3D; new HeroNode(2, &quot;小卢&quot;, &quot;玉麒麟~~&quot;);</span><br><span class="line">		singleLinkedList.update(newHeroNode);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;修改后的链表情况&quot;);</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;删除一个节点</span><br><span class="line">		singleLinkedList.del(4);</span><br><span class="line">		System.out.println(&quot;删除后的链表情况&quot;);</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;测试一下 求单链表中有效节点的个数</span><br><span class="line">		System.out.println(&quot;有效的节点个数&#x3D;&quot; + getLength(singleLinkedList.getHead()));&#x2F;&#x2F;2</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;测试一下看看是否得到了倒数第K个节点</span><br><span class="line">		HeroNode res &#x3D; findLastIndexNode(singleLinkedList.getHead(), 3);</span><br><span class="line">		System.out.println(&quot;res&#x3D;&quot; + res);</span><br><span class="line">*&#x2F;		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><h2 id="创建一个类，声明的的每一个对象都是一个单链表的节点-1"><a href="#创建一个类，声明的的每一个对象都是一个单链表的节点-1" class="headerlink" title="创建一个类，声明的的每一个对象都是一个单链表的节点"></a>创建一个类，声明的的每一个对象都是一个单链表的节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">	public int no;</span><br><span class="line">	public String name;</span><br><span class="line">	public String nickname;</span><br><span class="line">	public HeroNode2 next; &#x2F;&#x2F; 指向下一个节点, 默认为null</span><br><span class="line">	public HeroNode2 pre; &#x2F;&#x2F; 指向前一个节点, 默认为null</span><br><span class="line">	&#x2F;&#x2F; 构造器</span><br><span class="line"></span><br><span class="line">	public HeroNode2(int no, String name, String nickname) &#123;</span><br><span class="line">		this.no &#x3D; no;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.nickname &#x3D; nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 为了显示方法，我们重新toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickname&#x3D;&quot; + nickname + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建一个类，声明的的每一个对象都是一条双向链表"><a href="#创建一个类，声明的的每一个对象都是一条双向链表" class="headerlink" title="创建一个类，声明的的每一个对象都是一条双向链表"></a>创建一个类，声明的的每一个对象都是一条双向链表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个双向链表的类</span><br><span class="line">class DoubleLinkedList &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">	private HeroNode2 head &#x3D; new HeroNode2(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 返回头节点</span><br><span class="line">	public HeroNode2 getHead() &#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 遍历双向链表的方法</span><br><span class="line">	&#x2F;&#x2F; 显示链表[遍历]</span><br><span class="line">	public void list() &#123;</span><br><span class="line">		……</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 添加一个节点到双向链表的最后</span><br><span class="line">	public void add(HeroNode2 heroNode) &#123;</span><br><span class="line">		……</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">     *添加节点到单向链表</span><br><span class="line">	 *根据排名将英雄插入到指定位置</span><br><span class="line">     *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;(如果有这个排名，则添加失败，并给出提示)</span><br><span class="line">	public void addByOrder(HeroNode2 heroNode) &#123;</span><br><span class="line">		……</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 修改一个节点的内容</span><br><span class="line">	public void update(HeroNode2 newHeroNode) &#123;</span><br><span class="line">		……</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 从双向链表中删除一个节点,</span><br><span class="line">	public void del(int no) &#123;</span><br><span class="line">		……</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加节点到单向链表-1"><a href="#添加节点到单向链表-1" class="headerlink" title="添加节点到单向链表"></a>添加节点到单向链表</h2></li>
<li>在链表的末尾顺次添加</li>
<li>在链表的指定位置添加<h3 id="在链表的末尾添加-1"><a href="#在链表的末尾添加-1" class="headerlink" title="在链表的末尾添加"></a>在链表的末尾添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加一个节点到双向链表的最后.</span><br><span class="line">public void add(HeroNode2 heroNode) &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">	HeroNode2 temp &#x3D; head;</span><br><span class="line">	&#x2F;&#x2F; 遍历链表，找到最后</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		&#x2F;&#x2F; 找到链表的最后</span><br><span class="line">		if (temp.next &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 如果没有找到最后, 将将temp后移</span><br><span class="line">		temp &#x3D; temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 当退出while循环时，temp就指向了链表的最后</span><br><span class="line">	&#x2F;&#x2F; 形成一个双向链表</span><br><span class="line">	temp.next &#x3D; heroNode;</span><br><span class="line">	heroNode.pre &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在链表的指定位置添加"><a href="#在链表的指定位置添加" class="headerlink" title="在链表的指定位置添加"></a>在链表的指定位置添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void addByOrder(HeroNode2 heroNode) &#123;</span><br><span class="line">	&#x2F;&#x2F;因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span><br><span class="line">	&#x2F;&#x2F;因为单链表，因为我们找的temp是位于 添加位置的前一个节点，否则插入不了</span><br><span class="line">	HeroNode2 temp &#x3D; head;</span><br><span class="line">	boolean flag &#x3D; false; &#x2F;&#x2F; flag标志添加的编号是否存在，默认为false</span><br><span class="line">	while(true) &#123;</span><br><span class="line">		if(temp.next &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;说明temp已经在链表的最后</span><br><span class="line">			break; </span><br><span class="line">		&#125; </span><br><span class="line">		if(temp.next.no &gt; heroNode.no) &#123; &#x2F;&#x2F;位置找到，就在temp的后面插入</span><br><span class="line">			break;</span><br><span class="line">		&#125; else if (temp.next.no &#x3D;&#x3D; heroNode.no) &#123;&#x2F;&#x2F;说明希望添加的heroNode的编号已然存在</span><br><span class="line">			</span><br><span class="line">			flag &#x3D; true; &#x2F;&#x2F;说明编号存在</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		temp &#x3D; temp.next; &#x2F;&#x2F;后移，遍历当前链表</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;判断flag 的值</span><br><span class="line">	if(flag) &#123; &#x2F;&#x2F;不能添加，说明编号存在</span><br><span class="line">		System.out.printf(&quot;准备插入的英雄的编号 %d 已经存在了, 不能加入\n&quot;, heroNode.no);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		&#x2F;&#x2F;插入到链表中, temp的后面</span><br><span class="line">		heroNode.next &#x3D; temp.next;</span><br><span class="line">		temp.next.pre &#x3D; heroNode;</span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">		heroNode.pre &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改节点的信息-1"><a href="#修改节点的信息-1" class="headerlink" title="修改节点的信息"></a>修改节点的信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span><br><span class="line">&#x2F;&#x2F; 只是 节点类型改成 HeroNode2</span><br><span class="line">public void update(HeroNode2 newHeroNode) &#123;</span><br><span class="line">	&#x2F;&#x2F; 判断是否空</span><br><span class="line">	if (head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">		System.out.println(&quot;链表为空~&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 找到需要修改的节点, 根据no编号</span><br><span class="line">	&#x2F;&#x2F; 定义一个辅助变量</span><br><span class="line">	HeroNode2 temp &#x3D; head.next;</span><br><span class="line">	boolean flag &#x3D; false; &#x2F;&#x2F; 表示是否找到该节点</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		if (temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">			break; &#x2F;&#x2F; 已经遍历完链表</span><br><span class="line">		&#125;</span><br><span class="line">		if (temp.no &#x3D;&#x3D; newHeroNode.no) &#123;</span><br><span class="line">			&#x2F;&#x2F; 找到</span><br><span class="line">			flag &#x3D; true;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		temp &#x3D; temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 根据flag 判断是否找到要修改的节点</span><br><span class="line">	if (flag) &#123;</span><br><span class="line">		temp.name &#x3D; newHeroNode.name;</span><br><span class="line">		temp.nickname &#x3D; newHeroNode.nickname;</span><br><span class="line">	&#125; else &#123; &#x2F;&#x2F; 没有找到</span><br><span class="line">		System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除某一个节点-1"><a href="#删除某一个节点-1" class="headerlink" title="删除某一个节点"></a>删除某一个节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从双向链表中删除一个节点,</span><br><span class="line">&#x2F;&#x2F; 说明</span><br><span class="line">&#x2F;&#x2F; 1 对于双向链表，我们可以直接找到要删除的这个节点</span><br><span class="line">&#x2F;&#x2F; 2 找到后，自我删除即可</span><br><span class="line">public void del(int no) &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 判断当前链表是否为空</span><br><span class="line">	if (head.next &#x3D;&#x3D; null) &#123;&#x2F;&#x2F; 空链表</span><br><span class="line">		System.out.println(&quot;链表为空，无法删除&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HeroNode2 temp &#x3D; head.next; &#x2F;&#x2F; 辅助变量(指针)</span><br><span class="line">	boolean flag &#x3D; false; &#x2F;&#x2F; 标志是否找到待删除节点的</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		if (temp &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 已经到链表的最后</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (temp.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">			&#x2F;&#x2F; 找到的待删除节点的前一个节点temp</span><br><span class="line">			flag &#x3D; true;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		temp &#x3D; temp.next; &#x2F;&#x2F; temp后移，遍历</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 判断flag</span><br><span class="line">	if (flag) &#123; &#x2F;&#x2F; 找到</span><br><span class="line">		&#x2F;&#x2F; 可以删除</span><br><span class="line">		&#x2F;&#x2F; temp.next &#x3D; temp.next.next;[单向链表]</span><br><span class="line">		temp.pre.next &#x3D; temp.next;</span><br><span class="line">		&#x2F;&#x2F; 这里我们的代码有问题?</span><br><span class="line">		&#x2F;&#x2F; 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span><br><span class="line">		if (temp.next !&#x3D; null) &#123;</span><br><span class="line">			temp.next.pre &#x3D; temp.pre;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		System.out.printf(&quot;要删除的 %d 节点不存在\n&quot;, no);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="显示、遍历单链表-1"><a href="#显示、遍历单链表-1" class="headerlink" title="显示、遍历单链表"></a>显示、遍历单链表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 遍历双向链表的方法</span><br><span class="line">&#x2F;&#x2F; 显示链表[遍历]</span><br><span class="line">public void list() &#123;</span><br><span class="line">	&#x2F;&#x2F; 判断链表是否为空</span><br><span class="line">	if (head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">		System.out.println(&quot;链表为空&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">	HeroNode2 temp &#x3D; head.next;</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		&#x2F;&#x2F; 判断是否到链表最后</span><br><span class="line">		if (temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 输出节点的信息</span><br><span class="line">		System.out.println(temp);</span><br><span class="line">		&#x2F;&#x2F; 将temp后移， 一定小心</span><br><span class="line">		temp &#x3D; temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取到单链表的节点的个数-如果是带头结点的链表，需求不统计头节点-1"><a href="#获取到单链表的节点的个数-如果是带头结点的链表，需求不统计头节点-1" class="headerlink" title="获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)"></a>获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * @param head 链表的头节点</span><br><span class="line"> * @return 返回的就是有效节点的个数</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int getLength(HeroNode2 head) &#123;</span><br><span class="line">	if(head.next &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;空链表</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int length &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;定义一个辅助的变量, 这里我们没有统计头节点</span><br><span class="line">	HeroNode2 cur &#x3D; head.next;</span><br><span class="line">	while(cur !&#x3D; null) &#123;</span><br><span class="line">		length++;</span><br><span class="line">		cur &#x3D; cur.next; &#x2F;&#x2F;遍历</span><br><span class="line">	&#125;</span><br><span class="line">	return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; 测试</span><br><span class="line">		System.out.println(&quot;双向链表的测试&quot;);</span><br><span class="line">		&#x2F;&#x2F; 先创建节点</span><br><span class="line">		HeroNode2 hero1 &#x3D; new HeroNode2(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">		HeroNode2 hero2 &#x3D; new HeroNode2(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">		HeroNode2 hero3 &#x3D; new HeroNode2(4, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">		HeroNode2 hero4 &#x3D; new HeroNode2(5, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 创建一个双向链表</span><br><span class="line">		DoubleLinkedList doubleLinkedList &#x3D; new DoubleLinkedList();</span><br><span class="line">		doubleLinkedList.add(hero1);</span><br><span class="line">		doubleLinkedList.add(hero2);</span><br><span class="line">		doubleLinkedList.add(hero3);</span><br><span class="line">		doubleLinkedList.add(hero4);</span><br><span class="line">		</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 修改</span><br><span class="line">		HeroNode2 newHeroNode &#x3D; new HeroNode2(3, &quot;公孙胜&quot;, &quot;入云龙&quot;);</span><br><span class="line">		</span><br><span class="line">		doubleLinkedList.update(newHeroNode);</span><br><span class="line">		System.out.println(&quot;修改后的链表情况&quot;);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;在链表的指定位置添加</span><br><span class="line">		doubleLinkedList.addByOrder(newHeroNode);</span><br><span class="line">		System.out.println(&quot;修改后的链表情况&quot;);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 删除</span><br><span class="line">		doubleLinkedList.del(3);</span><br><span class="line">		System.out.println(&quot;删除后的链表情况~~&quot;);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="单向环形链表"><a href="#单向环形链表" class="headerlink" title="单向环形链表"></a>单向环形链表</h1></li>
</ul>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h4>
单向链表分析：<a href="/download/java_data_structure/SingleLinkedListDemo.java" download="SingleLinkedListDemo.java">点击下载</a>
</h4>
<h4>
双向链表分析：<a href="/download/java_data_structure/DoubleLinkedListDemo.java" download="DoubleLinkedListDemo.java" color: orange;>点击下载</a>
</h4>


        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>master</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"># Java_数据结构</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/07/01/java_data_structure_%E5%93%88%E5%B8%8C%E8%A1%A8/">Java_data_structure_哈希表</a>
            
            
            <a class="next" rel="next" href="/2020/06/26/css-%E9%98%B4%E5%BD%B1_%E8%BD%AE%E5%BB%93_%E5%9C%86%E8%A7%92/">CSS阴影_轮廓_圆角</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© master | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    总访客量:
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>&nbsp;


<span class="site-pv">
    总访问量:
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

&nbsp;&nbsp;
2019 - 2020
</footer>

    </div>
</body>
</html>
